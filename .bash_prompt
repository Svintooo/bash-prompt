#
# Bash prompt
#


# Custom Prompt
if false; then


  # Cleanup default prompt and enable custom prompt
  declare -F ___prompt_deactivate >/dev/null && ___prompt_deactivate
  eval "$(oh-my-posh init bash --config $HOME/.cache/oh-my-posh/themes/peru.omp.json)"


# Default Prompt
else


  # Array of variables to be unset at script end
  declare -a PreCommands=()
  declare -a PostCommands=()
  declare -a RuntimeDeclares=()
  declare -a ScriptDeclares=( ScriptDeclares RuntimeDeclares PostCommands PreCommands )


  # Define control codes
  # https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  declare Esc='\033'                                       # Same as '\e'
  declare CursorSave="${Esc}[s"  CursorRestore="${Esc}[u"  # Cursor Position
  declare HideStart='\['         HideEnd='\]'              # Hide non-printing chars, prevent cursor b0rk
  declare CmdStop="${Esc}"'\\'
  declare CmdTitle="${Esc}]0;"                             # Set Window/Tab titlebar text
  declare OSCPromptStart="${Esc}]133;A${CmdStop}"      #TODO /etc/profile.d/vte-2.91.sh
  declare OSCPromptEnd="${Esc}]133;B${CmdStop}"        #TODO /etc/profile.d/vte-2.91.sh
  declare OSCReportRetval="${Esc}]133;D\$?${CmdStop}"  #TODO /etc/profile.d/vte-2.91.sh
  ScriptDeclares+=( Esc CursorSave CursorRestore HideStart HideEnd CmdStop CmdTitle OSCPromptStart OSCPromptEnd OSCReportRetval )

  if [[ "$TERM" =~ ^xterm-color$|.*-256color$ ]]; then
    declare  Reset="${Esc}[0;00m"
    declare  Black="${Esc}[0;30m"    DarkGrey="${Esc}[1;30m"
    declare    Red="${Esc}[0;31m"    LightRed="${Esc}[1;31m"
    declare  Green="${Esc}[0;32m"  LightGreen="${Esc}[1;32m"
    declare  Brown="${Esc}[0;33m"      Yellow="${Esc}[1;33m"
    declare   Blue="${Esc}[0;34m"   LightBlue="${Esc}[1;34m"
    declare Purple="${Esc}[0;35m" LightPurple="${Esc}[1;35m"
    declare   Cyan="${Esc}[0;36m"   LightCyan="${Esc}[1;36m"
    declare   Grey="${Esc}[0;37m"       White="${Esc}[1;37m"

    colors=(
      Reset
      Black    Red      Green      Brown  Blue      Purple      Cyan      Grey
      DarkGrey LightRed LightGreen Yellow LightBlue LightPurple LightCyan White
    )
    for color in "${colors[@]}"; do
      declare "H${color}"="${HideStart}${!color}${HideEnd}"  # declare hidden version of each color
      ScriptDeclares+=( "${color}" "H${color}" )
    done
    unset color colors
  fi

  # NOTES
  #
  # - Any code $(...) run inside PS1 needs to preserve exit code $?.
  #   Example: $(r=$? ; ... ; exit $r)
  #     Test: ( exit 1 )
  #           echo "This should be 1: $?"
  #
  # - Resetting cursor position using carriage return (\r) is bad.
  #   It risks hiding command outputs that do not end with a newline (\n).
  #     Test: echo -n 'this should be visible'
  #
  # - Prevent executing malicious code. Never do integer operations on
  #   user controlled variables.
  #     Dangerous: (( var += 1 )), $(( var - 1 )), [[ "$var" -eq 1 ]] 
  #     Safe:      [[ "$var" == 1 ]], [[ "$var" > 0 ]], [[ -z "$var" ]]
  #     Example: var='PATH=0'
  #              (( var + 1 ))
  #              echo "$PATH"
  #     Example: var='arr[$(echo "U r h4cked" > HACKED.TXT)]'
  #              (( var + 1 ))
  #              cat HACKED.TXT


  # Helper functions
  function ___prompt_right_aligned() {
    local escseq='('$'\x01''?'$'\e''([@A-Z\[\\^_]|\])[0-9:;<=>?]*[-!"#$%&()*,./'"'"']*([@A-Z\[\\^_`a-z{|}~]|\]))'$'\x02''?'
    local str_no_escseq="$( echo "${1@P}" | sed -E "s/$escseq//g" )"
    local width="${#str_no_escseq}"
    local cols="$( [[ "$COLUMNS" ]] && echo "$COLUMNS" || tput cols )"
    local cursor_save="\\e[s"  move_right="\\e[${cols}C"
    local cursor_load="\\e[u"  move_left="\\e[$((width-1))D"
    if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
      printf "${cursor_save}${move_right}${move_left}%s${cursor_load}" "$1"
    else
      printf '\n'"%$((cols-width))s"'%s''\r' "" "$1"
    fi
  }

  eval '
  function ___prompt_title() {
    echo -ne '"'${CmdTitle}'"'
    # IMPORTANT: Prevent printing eventual control codes inside BASH_COMMAND
    echo -n "${BASH_COMMAND//[[:cntrl:]]/^?}"
    echo -ne '"'${CmdStop}'"'
  }'

  #NOTE: Will not run if you only press enter on an empty prompt
  function ___prompt_pre_cmd() {
    # Switch between single line and multiline prompt
    ___prompt_layout="full"

    # Execution time
    if [[ -z "$___prompt_cmdtime_start" ]]; then
      ___prompt_cmdtime_start="$EPOCHSECONDS"
    fi
  }

  function ___prompt_post_cmd() {
    # Switch between single line and multiline prompt
    case "$___prompt_layout" in
      (minimal)
        PS1="${___prompt_PS1##*\\n}" ;;
      (full|*)
        PS1="$___prompt_PS1" ;;
    esac
    ___prompt_layout="minimal"

    # Execution time
    if [[ "$___prompt_cmdtime_start" =~ ^[0-9]+$ && "$EPOCHSECONDS" =~ ^[0-9]+$ ]]; then
      ___cmdtime_elapsed="$(( EPOCHSECONDS - ___prompt_cmdtime_start - 62167219200 ))"
      ___cmdtime_elapsed="$( date -ud "@${___cmdtime_elapsed}" +'%y %j %H %M %S' )"
      ___cmdtime_elapsed="$( awk '{print " "$1-0"y "$2-1"d "$3-0"h "$4-0"m "$5-0"s"}' <<<"$___cmdtime_elapsed" )"
      ___cmdtime_elapsed="${___cmdtime_elapsed// 0?/}"
      ___cmdtime_elapsed="${___cmdtime_elapsed#${___cmdtime_elapsed%% *}}"
      ___prompt_cmdtime_start=""
    fi
  }

  PreCommands+=( ___prompt_pre_cmd )
  PostCommands+=( ___prompt_post_cmd )
  RuntimeDeclares+=( ___prompt_right_aligned ___prompt_title ___prompt_pre_cmd ___prompt_post_cmd ___prompt_layout ___prompt_PS1 )


  # Set Prompt
  declare TimeStamp="${HLightCyan}"'$(r=$? ; date +"%Y-%m-%d %H:%M:%S %:z" ; exit $r)'"${HReset}"
  declare RetCode="${HRed}"'$(r=$? ; [[ "$r" == "0" ]] || echo "$r" ; exit $r)'"${HReset}"
  declare NoNewline='$(r=$?; printf "\033[6n" > /dev/tty ; IFS=";" read -r -d"R" _ col < /dev/tty ;  ;exit $r)' #WiP
  declare BeatTime="${HYellow}"'[$(r=$? ; date +"%Y-%m-%d" ; exit $r)$(r=$? ; date -u +"%s" | awk "{printf \"@%.2f\", (((\\$1+3600)%86400)/86.4)}" ; exit $r)]'"${HReset}"
  declare ShellLevel="$( [[ "$SHLVL" != "1" ]] && echo "[$SHLVL]" )"
  declare ExitCode='$(r=$? ; [[ $r == 0 ]] || echo ":'"${HBrown}"'${r}'"${HReset}"'" ; exit ${r})'
  declare GitBranch='$(r=$? ; git symbolic-ref --short HEAD 2>/dev/null | sed "/./s/.*/[&]/" ; exit $r)'
  declare CmdDuration='$(r=$? ; [[ "$___cmdtime_elapsed" =~ ^0?$ ]] || echo "'"${HYellow}"'${___cmdtime_elapsed}'"${HReset}"'" ; exit $r)'
  declare UserColor="$( [[ "$USER" == root ]] && echo "$HRed" || echo "$HGreen" )"
  declare UserHost="${HLightCyan}"'\u@\h'"${HReset}"
  declare PwdFolder="${HBlue}"'$(r=$? ; pwd="${PWD/$HOME/\~}" ; pwd="${pwd##*/}"; echo "${pwd}/" ; exit $r)'"${HReset}"
  declare Pwd="${HCyan}"'\w'"${HReset}"
  ScriptDeclares+=( TimeStamp RetCode NoNewline BeatTime ShellLevel ExitCode GitBranch CmdDuration UserColor UserHost PwdFolder Pwd )
  PS1='$(r=$?;(exit $r); ___prompt_right_aligned "'"${RetCode}${CmdDuration} ${TimeStamp}"'" ;exit $r)'
  PS1+="${UserHost}:${Pwd}"'\n'
  PS1+="${GitBranch}${UserColor}"'\$'"${HReset}${ShellLevel} "
  #
  #PS1="${BeatTime}${UserHost}:${PwdFolder}${ShellLevel}\\$ "
  #
  ___prompt_PS1="$PS1"


  # Set titlebar
  if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
    # Set default title
    PS1="${PS1}""${HideStart}${CmdTitle}\u@\h:\w${CmdStop}${HideEnd}"
    ___prompt_PS1="$PS1"

    # Set title to the command being executed
    PreCommands+=( ___prompt_title )
  fi


  # Post: Custom PROMPT_COMMAND handler
  declare -a ___prompt_PROMPT_COMMAND=( "${PROMPT_COMMAND[@]}" )
  unset PROMPT_COMMAND
  declare PROMPT_COMMAND="___prompt_commands"
  function ___prompt_commands() {
    local cmd prompt_command

    # Restore modified PROMPT_COMMAND if it was modified
    if [[ "${PROMPT_COMMAND[*]}" != "$FUNCNAME" ]]; then
      for cmd in "${PROMPT_COMMAND[@]}"; do
        prompt_command="$( sed -E "s/;\s*$FUNCNAME\s*;/;/g ; s/^\s*;+\s*|\s*;+\s*$//g" <<<";$cmd;" )"
        if [[ -n "$prompt_command" ]] && ! printf '%s\0' "${___prompt_PROMPT_COMMAND[@]}" | grep -qzxF "$prompt_command"; then
          ___prompt_PROMPT_COMMAND+=( "$prompt_command" )
        fi
      done
      unset PROMPT_COMMAND
      declare -g PROMPT_COMMAND="$FUNCNAME"
    fi

    # Run prompt commands
    for cmd in "${___prompt_PROMPT_COMMAND[@]}"; do
      eval "$cmd"
    done
  }
  RuntimeDeclares+=( ___prompt_commands ___prompt_PROMPT_COMMAND )


  # Post: PostCommands
  for cmd in "${PostCommands[@]}"; do
    if ! printf '%s\0' "${___prompt_PROMPT_COMMAND[@]}" | grep -qzxF "$cmd"; then
      ___prompt_PROMPT_COMMAND+=( "$cmd" )
    fi
  done
  unset cmd


  # Post: PreCommands
  trap 'if [[ "$BASH_COMMAND" != "___prompt_commands" ]]; then '"$( IFS=';' ; echo "${PreCommands[*]}" )"'; fi' DEBUG


  # Post: Define a prompt deactivation function
  eval '
  function ___prompt_deactivate() {
    # Set Prompt
    PS1='\''\u@\h:\w\$ '\''

    # Set Title
    if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
      printf '"'${CmdTitle}${USER}@${HOSTNAME}${CmdStop}'"'
    fi

    # Remove Prompt Commands
    local cmd cmds=()
    for cmd in "${___prompt_PROMPT_COMMAND[@]}"; do
      if ! printf '"'%s\0'"' '"${RuntimeDeclares[@]@Q}"' | grep -qzxF "$cmd"; then
        cmds+=( "$cmd" )
      fi
    done
    unset PROMPT_COMMAND
    PROMPT_COMMAND="$( IFS=";" ; echo "${cmds[*]}" )"

    # Unset variables and functions
    '"$( printf 'unset %s\n    ' "${RuntimeDeclares[@]}" )"'
    unset -f "$FUNCNAME"
  }'
  # Deleting the DEBUG trap cannot be done inside a function
  alias ___prompt_deactivate='trap - DEBUG ; unalias ___prompt_deactivate ; ___prompt_deactivate'


  # Post: Cleanup
  unset "${ScriptDeclares[@]}"


fi
