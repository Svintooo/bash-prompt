#
# Bash prompt
#


# Custom Prompt
if false; then


  # Cleanup default prompt and enable custom prompt
  declare -F ___prompt_deactivate >/dev/null && ___prompt_deactivate
  eval "$(oh-my-posh init bash --config $HOME/.cache/oh-my-posh/themes/peru.omp.json)"


# Default Prompt (requires bash >= 5.2)
elif (( BASH_VERSINFO[0] > 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 2) )); then


  # Array of variables to be unset at script end
  declare -a PreCommands=()
  declare -a PostCommands=()
  declare -a RuntimeDeclares=()
  declare -a ScriptDeclares=( ScriptDeclares RuntimeDeclares PreCommands PostCommands )


  # Make sure PROMPT_COMMAND is an array
  if [[ "$(declare -p PROMPT_COMMAND 2>/dev/null)" != "declare -a"* ]]; then
    declare -a PROMPT_COMMAND=( "$PROMPT_COMMAND" )
    [[ -n "${PROMPT_COMMAND[0]}" ]] || PROMPT_COMMAND=()
  fi


  # Define control codes
  # https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b
  declare Esc='\033'                                       # Same as '\e'
  declare CursorSave="${Esc}[s"  CursorRestore="${Esc}[u"  # Cursor Position
  declare HideStart='\['         HideEnd='\]'              # Hide non-printing chars, prevent cursor b0rk
  declare CmdStop="${Esc}"'\\'
  declare CmdTitle="${Esc}]0;"                             # Set Window/Tab titlebar text
  declare OSCPromptStart="${Esc}]133;A${CmdStop}"      #TODO /etc/profile.d/vte-2.91.sh
  declare OSCPromptEnd="${Esc}]133;B${CmdStop}"        #TODO /etc/profile.d/vte-2.91.sh
  declare OSCReportRetval="${Esc}]133;D\$?${CmdStop}"  #TODO /etc/profile.d/vte-2.91.sh
  ScriptDeclares+=( Esc CursorSave CursorRestore HideStart HideEnd CmdStop CmdTitle OSCPromptStart OSCPromptEnd OSCReportRetval )

  if [[ "$TERM" =~ ^xterm-color$|.*-256color$ ]]; then
    declare  Reset="${Esc}[0;00m"
    declare  Black="${Esc}[0;30m"    DarkGrey="${Esc}[1;30m"
    declare    Red="${Esc}[0;31m"    LightRed="${Esc}[1;31m"
    declare  Green="${Esc}[0;32m"  LightGreen="${Esc}[1;32m"
    declare  Brown="${Esc}[0;33m"      Yellow="${Esc}[1;33m"
    declare   Blue="${Esc}[0;34m"   LightBlue="${Esc}[1;34m"
    declare Purple="${Esc}[0;35m" LightPurple="${Esc}[1;35m"
    declare   Cyan="${Esc}[0;36m"   LightCyan="${Esc}[1;36m"
    declare   Grey="${Esc}[0;37m"       White="${Esc}[1;37m"

    colors=(
      Reset
      Black    Red      Green      Brown  Blue      Purple      Cyan      Grey
      DarkGrey LightRed LightGreen Yellow LightBlue LightPurple LightCyan White
    )
    for color in "${colors[@]}" ; do
      declare "H${color}"="${HideStart}${!color}${HideEnd}"  # declare hidden version of each color
      ScriptDeclares+=( "${color}" "H${color}" )
    done
    unset color colors
  fi


  # NOTES
  #
  # - Any code $(...) run inside PS1 needs to preserve exit code $?.
  #   Example: $(r=$? ; ... ; exit $r)
  #     Test: ( exit 1 )
  #           echo "This should be 1: $?"
  #
  # - Resetting cursor position using carriage return (\r) is bad.
  #   It risks hiding command outputs that do not end with a newline (\n).
  #     Test: echo -n 'this should be visible'
  #
  # - Prevent executing malicious code. Never do integer operations on
  #   user controlled variables.
  #     Dangerous: (( var += 1 )), $(( var - 1 )), [[ "$var" -eq 1 ]] 
  #     Safe:      [[ "$var" == 1 ]], [[ "$var" > 0 ]], [[ -z "$var" ]]
  #     Example: var='PATH=0'
  #              (( var + 1 ))
  #              echo "$PATH"
  #     Example: var='arr[$(echo "U r h4cked" > HACKED.TXT)]'
  #              (( var + 1 ))
  #              cat HACKED.TXT
  #
  # - Adding a right aligned prompt in Bash is a hack and will always behave
  #   strangely. The prompt in this script tries to only let tolerable
  #   strangenesses to occur.


  # Helper functions
  ___prompt_right_aligned() {
    local escseq='('$'\x01''?'$'\e''([@A-Z\[\\^_]|\])[0-9:;<=>?]*[-!"#$%&()*,./'"'"']*([@A-Z\[\\^_`a-z{|}~]|\]))'$'\x02''?'
    local str_no_escseq="$( echo "${1@P}" | sed -E "s/$escseq//g" )"
    local width="${#str_no_escseq}"
    local cols="$( [[ "$COLUMNS" ]] && echo "$COLUMNS" || tput cols )"
    local cursor_save="\\e[s"  move_right="\\e[${cols}C"
    local cursor_load="\\e[u"  move_left="\\e[$((width-1))D"
    if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
      printf "${cursor_save}${move_right}${move_left}%s${cursor_load}" "$1"
    else
      printf '\n'"%$((cols-width))s"'%s''\r' "" "$1"
    fi
  }

  eval '
  ___prompt_title() {
    echo -ne '"'${CmdTitle}'"'
    # IMPORTANT: Prevent printing eventual control codes inside BASH_COMMAND
    echo -n "${BASH_COMMAND//[[:cntrl:]]/^?}"
    echo -ne '"'${CmdStop}'"'
  }'

  ___prompt_pre_cmd() {
    if ! printf '%s\0' "${PROMPT_COMMAND[@]}" | grep -qzxF "$BASH_COMMAND"; then
      # THIS CODE RUNS BEFORE EACH USER COMMAND
      ___prompt_layout="full"
      # THIS CODE RUNS BEFORE EACH USER COMMAND
    fi
  }

  ___prompt_post_cmd() {
    # THIS CODE RUNS AFTER EACH USER COMMAND
    case "$___prompt_layout" in
      (minimal)
        PS1="${___prompt_PS1##*\n}" ;;
      (full|*)
        PS1="$___prompt_PS1" ;;
    esac
    ___prompt_layout="minimal"
    # THIS CODE RUNS AFTER EACH USER COMMAND
  }

  PreCommands+=( "___prompt_pre_cmd" )
  PostCommands+=( "___prompt_post_cmd" )
  RuntimeDeclares+=( ___prompt_right_aligned ___prompt_title ___prompt_pre_cmd ___prompt_post_cmd ___prompt_layout ___prompt_PS1 )


  # Set Prompt
  declare TimeStamp="${HYellow}"'$(r=$? ; date +"%Y-%m-%d %H:%M:%S %:z" ; exit $r)'"${HReset}"
  declare RetCode="${HRed}"'$(r=$? ; [[ "$r" == "0" ]] || echo "$r" ; exit $r)'"${HReset}"
  declare NoNewline='$(r=$?; printf "\033[6n" > /dev/tty ; IFS=";" read -r -d"R" _ col < /dev/tty ;  ;exit $r)' #WiP
  declare BeatTime="${HYellow}"'[$(r=$? ; date +"%Y-%m-%d" ; exit $r)$(r=$? ; date -u +"%s" | awk "{printf \"@%.2f\", (((\\$1+3600)%86400)/86.4)}" ; exit $r)]'"${HReset}"
  declare ShellLevel="$( [[ "$SHLVL" != "1" ]] && echo "[$SHLVL]" )"
  declare ExitCode='$(r=$? ; [[ $r == 0 ]] || echo ":'"${HBrown}"'${r}'"${HReset}"'" ; exit ${r})'
  declare UserColor="$( [[ "$USER" == root ]] && echo "$HRed" || echo "$HGreen" )"
  declare UserHost="${UserColor}"'\u@\h'"${HReset}"
  declare PwdFolder="${HBlue}"'$(r=$? ; pwd="${PWD/$HOME/\~}" ; pwd="${pwd##*/}"; echo "${pwd}/" ; exit $r)'"${HReset}"
  declare Pwd="${HBlue}"'\w'"${HReset}"
  ScriptDeclares+=( TimeStamp RetCode BeatTime ShellLevel ExitCode UserColor UserHost PwdFolder )
  PS1='$(r=$?;(exit $r); ___prompt_right_aligned "'"${RetCode} ${TimeStamp}"'" ;exit $r)'
  PS1+="${UserHost}:${Pwd}${ShellLevel}"'\n'
  PS1+='\$ '
  #
  #PS1="${BeatTime}${UserHost}:${PwdFolder}${ShellLevel}\\$ "
  #
  ___prompt_PS1="$PS1"


  # Set titlebar
  if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
    # Set default title
    PS1="${HideStart}${CmdTitle}\u@\h:\w${CmdStop}${HideEnd}""${PS1}"
    ___prompt_PS1="$PS1"

    # Set title to the command being executed
    PreCommands+=( "___prompt_title" )
  fi


  # Set Right Prompt
  if false; then
    eval '
    ___prompt_right() {
      local r="$?" ; [[ "$r" == "0" ]] && r="" || r="${r} "
      #local timestamp="$(date +"%Y-%m-%d %H:%M:%S %:z")"
      #local rprompt='"'${Red}'"'"${r}"'"'${Yellow}'"'"${timestamp}"'"'${Reset}'"'
      #local rprompt_nocolor="${r}${timestamp}"
      local rprompt='"'${Red}'"'"${r}"'"'${Blue}'"'"${PWD}"'"'${Reset}'"'
      local rprompt_nocolor="${r}${PWD}"
      local cursor_save="\\e[s"  move_right="\\e[${COLUMNS:-$(tput cols)}C"
      local cursor_load="\\e[u"  move_left="\\e[$(( ${#rprompt_nocolor} - 1 ))D"
      printf "${cursor_save}${move_right}${move_left}${rprompt}${cursor_load}"
    }'
    PostCommands+=( "___prompt_right" )
    RuntimeDeclares+=( ___prompt_right )
  fi


  # Define a prompt deactivation function
  eval '
  ___prompt_deactivate() {
    # Set Prompt
    PS1='\''\u@\h:\w\$ '\''

    # Set Title
    if [[ "$TERM" =~ ^(xterm|rxvt) ]]; then
      printf '"'${CmdTitle}${USER}@${HOSTNAME}${CmdStop}'"'
    fi

    # Remove Prompt Commands
    local cmd cmds=()
    for cmd in "${PROMPT_COMMAND[@]}"; do
      if ! printf '"'%s\0'"' '"${RuntimeDeclares[@]@Q}"' | grep -qzxF "$cmd"; then
        cmds+=( "$cmd" )
      fi
    done
    PROMPT_COMMAND=( "${cmds[@]}" )

    # Unset variables and functions
    '"$( printf 'unset %s\n    ' "${RuntimeDeclares[@]}" )"'
    unset -f "$FUNCNAME"
  }'
  # Deleting the DEBUG trap cannot be done inside a function
  alias ___prompt_deactivate='trap - DEBUG ; unalias ___prompt_deactivate ; ___prompt_deactivate'


  # Post
  trap "$( IFS=';' ; echo "${PreCommands[*]}" )" DEBUG
  for cmd in "${PostCommands[@]}"; do
    if ! printf '%s\0' "${PROMPT_COMMAND[@]}" | grep -qzxF "$cmd"; then
      PROMPT_COMMAND+=( "$cmd" )
    fi
  done
  unset cmd


  # Cleanup
  unset "${ScriptDeclares[@]}"


fi
